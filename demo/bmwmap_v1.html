<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>BMW MQTT Map with Persistent Trails</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .hud {
      position:absolute; top:10px; left:80px;   /* <-- shifted right */
      z-index:1000;
      background:rgba(255,255,255,.9); padding:10px; border-radius:10px;
      font-family:system-ui,sans-serif; font-size:14px;
      box-shadow:0 4px 14px rgba(0,0,0,.12);
      min-width: 260px;
    }
    .row { display:flex; gap:8px; align-items:center; margin-top:6px; flex-wrap: wrap; }
    .dot { display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px;background:#aaa; }
    .dot.ok { background:#2ecc71; } .dot.err { background:#e74c3c; }
    .small { font-size:12px; opacity:0.8; }
    button { cursor:pointer; border:1px solid #ddd; border-radius:8px; padding:6px 10px; background:#fff; }
    select { border:1px solid #ddd; border-radius:6px; padding:4px 6px; }
    code { background:#f4f4f4; padding:1px 4px; border-radius:4px; }
  </style>
</head>
<body>
  <div class="hud">
    <div><span id="conn" class="dot"></span><strong>MQTT</strong> ws://192.168.10.88:9001</div>
    <div>Subscribed: <code>bmw/+ </code></div>

    <div class="row">
      <label for="vinSelect">Vehicle:</label>
      <select id="vinSelect" disabled>
        <option value="">populated automatically</option>
      </select>
    </div>

    <div class="row">
      <button id="clearTrailBtn">Clear trail</button>
      <button id="clearAllBtn">Clear all trails</button>
    </div>
    <div class="small" id="info">–</div>
  </div>

  <div id="map"></div>

  <script>
    const brokerUrl = "ws://192.168.10.88:9001";
    const subscribeTopic = "bmw/+";
    const MAX_POINTS = 1000;
    const MIN_DIST_METERS = 7;
    const STORAGE_PREFIX = "bmwTrack_";

    const map = L.map('map').setView([48.1372, 11.5756], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom:19, attribution:'&copy; OpenStreetMap'
    }).addTo(map);

    const connDot = document.getElementById('conn');
    const vinSelect = document.getElementById('vinSelect');
    const clearTrailBtn = document.getElementById('clearTrailBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const info = document.getElementById('info');
    const state = {};

    const haversine = (lat1, lon1, lat2, lon2) => {
      const toRad = d => d * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    };
    const keyForVin = vin => STORAGE_PREFIX + vin;

    function ensureVin(vin) {
      if (!state[vin]) {
        state[vin] = { lat:null, lon:null, marker:null, polyline:null, track:[] };
        loadTrail(vin);
        state[vin].polyline = L.polyline(state[vin].track.map(p => [p.lat, p.lon]), { weight:4 }).addTo(map);
        updateInfo(vin);
      }
      return state[vin];
    }

    function updateInfo(vin) {
      const s = state[vin];
      const count = s.track.length;
      const lastTime = count ? new Date(s.track[count-1].t).toLocaleString() : "–";
      info.textContent = `VIN: ${vin} • Points: ${count} • Last update: ${lastTime}`;
    }

    function saveTrail(vin) {
      const s = state[vin];
      if (s.track.length > MAX_POINTS) s.track.splice(0, s.track.length - MAX_POINTS);
      const compact = s.track.map(p => ({ lat:+p.lat.toFixed(6), lon:+p.lon.toFixed(6), t:p.t }));
      localStorage.setItem(keyForVin(vin), JSON.stringify(compact));
    }

    function loadTrail(vin) {
      try {
        const raw = localStorage.getItem(keyForVin(vin));
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) state[vin].track = arr.filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon));
      } catch {}
    }

    function clearTrail(vin) {
      const s = state[vin];
      s.track = [];
      saveTrail(vin);
      if (s.polyline) s.polyline.setLatLngs([]);
      updateInfo(vin);
    }

    function clearAllTrails() {
      Object.keys(state).forEach(vin => {
        localStorage.removeItem(keyForVin(vin));
        if (state[vin].polyline) state[vin].polyline.setLatLngs([]);
        state[vin].track = [];
        updateInfo(vin);
      });
    }

    function addTrackPoint(vin, lat, lon, ts = Date.now()) {
      const s = state[vin];
      const track = s.track;
      const last = track.length ? track[track.length - 1] : null;
      if (last) {
        const d = haversine(last.lat, last.lon, lat, lon);
        if (d < MIN_DIST_METERS) return;
      }
      const point = { lat, lon, t: typeof ts === "string" ? ts : new Date(ts).toISOString() };
      track.push(point);
      s.polyline.addLatLng([lat, lon]);
      saveTrail(vin);
      updateInfo(vin);
    }

    function maybeUpdateMarker(vin) {
      const s = state[vin];
      if (typeof s.lat === "number" && typeof s.lon === "number") {
        const pos = [s.lat, s.lon];
        if (!s.marker) s.marker = L.marker(pos).addTo(map);
        else s.marker.setLatLng(pos);
        s.marker.bindPopup(
          `<b>${vin}</b><br>Lat: ${s.lat.toFixed(6)}<br>Lon: ${s.lon.toFixed(6)}<br>${new Date().toLocaleTimeString()}`
        );
        map.setView(pos, Math.max(map.getZoom(), 13));
      }
    }

    function extractCoords(dataObj) {
      let lat = null, lon = null;
      const latObj = dataObj?.["vehicle.cabin.infotainment.navigation.currentLocation.latitude"];
      const lonObj = dataObj?.["vehicle.cabin.infotainment.navigation.currentLocation.longitude"];
      if (typeof latObj?.value === "number") lat = latObj.value;
      if (typeof lonObj?.value === "number") lon = lonObj.value;
      if (lat === null || lon === null) {
        for (const [k, v] of Object.entries(dataObj || {})) {
          const val = (v && typeof v === "object") ? v.value : undefined;
          if (typeof val === "number") {
            if (lat === null && k.endsWith(".latitude")) lat = val;
            if (lon === null && k.endsWith(".longitude")) lon = val;
          }
        }
      }
      return { lat, lon };
    }

    const client = mqtt.connect(brokerUrl, { reconnectPeriod:3000, connectTimeout:5000 });
    client.on('connect', () => { connDot.classList.remove('err'); connDot.classList.add('ok'); client.subscribe(subscribeTopic); });
    client.on('error', () => { connDot.classList.remove('ok'); connDot.classList.add('err'); });

    client.on('message', (topic, payload) => {
      let msg;
      try { msg = JSON.parse(payload.toString()); } catch { return; }
      const vin = msg.vin || msg.topic || "unknown";
      const data = msg.data || {};
      const { lat, lon } = extractCoords(data);
      const ts = msg.timestamp || Date.now();
      const s = ensureVin(vin);
      let changed = false;
      if (typeof lat === "number") { s.lat = lat; changed = true; }
      if (typeof lon === "number") { s.lon = lon; changed = true; }
      if (changed && typeof s.lat === "number" && typeof s.lon === "number") {
        addTrackPoint(vin, s.lat, s.lon, ts);
        maybeUpdateMarker(vin);
      }
    });

    clearTrailBtn.addEventListener('click', () => {
      const vin = Object.keys(state)[0];
      if (!vin) return alert("No vehicle data yet");
      if (!confirm(`Clear trail for ${vin}?`)) return;
      clearTrail(vin);
    });

    clearAllBtn.addEventListener('click', () => {
      if (!confirm("Clear all trails for all vehicles?")) return;
      clearAllTrails();
    });

    (function restoreExistingTrails() {
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith(STORAGE_PREFIX)) {
          const vin = k.slice(STORAGE_PREFIX.length);
          ensureVin(vin);
          const s = state[vin];
          if (s.track.length) {
            const last = s.track[s.track.length - 1];
            s.lat = last.lat; s.lon = last.lon;
            maybeUpdateMarker(vin);
          }
        }
      }
      if (Object.keys(state).length === 0) info.textContent = "Waiting for MQTT data...";
    })();
  </script>
</body>
</html>

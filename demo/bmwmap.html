<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>BMW MQTT Map with Persistent Trails</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    body { display: flex; flex-direction: column; font-family: system-ui, sans-serif; }

    /* Oberes Panel mit den Daten */
    #extraPanel {
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
      background: #fafafa;
    }
    #extraPanel h3 { margin: 0 0 8px 0; font-size: 16px; }
    #extraMeta { font-size: 12px; opacity: .8; margin-bottom: 8px; }
    #extraList {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 6px 14px;
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #extraList li {
      background: #fff;
      border: 1px solid #eee;
      border-radius: 8px;
      padding: 8px 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      min-height: 36px;
    }
    .k {
      flex: 1 1 auto;
      opacity: .8;
      word-break: break-word;
      white-space: normal;
      overflow-wrap: break-word;
      line-height: 1.2;
    }
    .v {
      flex: 0 0 auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      text-align: right;
      max-width: 45%;
      word-break: break-all;
    }

    /* HUD jetzt fest über der Karte */
    .hud {
      background: #fff;
      border-bottom: 1px solid #ccc;
      padding: 8px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      z-index: 10;
      font-size: 14px;
    }
    .dot { display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;background:#aaa;vertical-align:middle; }
    .dot.ok { background:#2ecc71; }
    .dot.err { background:#e74c3c; }
    button {
      cursor: pointer;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 6px 10px;
      background: #fff;
      font-size: 14px;
    }
    button:hover { background: #f4f4f4; }

    #info { font-size: 12px; opacity: .8; }

    /* Karte */
    #map { flex: 1 1 auto; }
  </style>
</head>
<body>

  <!-- 1️⃣ Fahrzeugdaten -->
  <section id="extraPanel">
    <h3>Fahrzeugdaten</h3>
    <div id="extraMeta" class="small">Warte auf Daten…</div>
    <ul id="extraList"><li><span class="k">–</span><span class="v">Noch nichts empfangen</span></li></ul>
  </section>

  <!-- 2️⃣ HUD – jetzt fester Teil der Seite -->
  <div class="hud">
    <div>
      <span id="conn" class="dot"></span>
      <strong>MQTT</strong> ws://192.168.10.88:9001
    </div>
    <div id="info">–</div>
    <div>
      <button id="clearTrailBtn">Trail löschen</button>
      <button id="clearAllBtn">Alles löschen</button>
    </div>
  </div>

  <!-- 3️⃣ Karte -->
  <div id="map"></div>


    <script>
    const brokerUrl = "ws://192.168.10.88:9001";
    const subscribeTopic = "bmw/+";
    const MAX_POINTS = 1000;
    const MIN_DIST_METERS = 7;
    const STORAGE_PREFIX = "bmwTrack_";
    const EXTRA_PREFIX = "bmwExtra_";

    const map = L.map('map').setView([48.1372, 11.5756], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom:19, attribution:'&copy; OpenStreetMap'
    }).addTo(map);

    const connDot = document.getElementById('conn');
    const clearTrailBtn = document.getElementById('clearTrailBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const info = document.getElementById('info');
    const extraMeta = document.getElementById('extraMeta');
    const extraList = document.getElementById('extraList');

    const state = {};        // per VIN: { lat, lon, marker, polyline, track[], extras:{} }

    const haversine = (lat1, lon1, lat2, lon2) => {
        const toRad = d => d * Math.PI / 180;
        const R = 6371000;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
        return 2 * R * Math.asin(Math.sqrt(a));
    };
    const keyForVin = vin => STORAGE_PREFIX + vin;
    const keyForExtra = vin => EXTRA_PREFIX + vin;

    // 1) State um Gruppierung nach Timestamp erweitern
    // pro VIN: Map tsKey -> { lat?:number, lon?:number, realTs:number, timer?:number }
    function ensureVin(vin) {
        if (!state[vin]) {
            state[vin] = { lat:null, lon:null, marker:null, polyline:null, track:[], extras:{},
                        groups: new Map() };
            loadTrail(vin);
            loadExtras(vin);
            state[vin].polyline = L.polyline(state[vin].track.map(p => [p.lat, p.lon]), { weight:4 }).addTo(map);
            updateInfo(vin);
            renderExtras(vin);
        }
        return state[vin];
    }

    // 2) Hilfen: Timestamp bestimmen & Gruppe committen
    function pickTsKeyAndMillis(msgTs, latObj, lonObj) {
        // bevorzugt den "inneren" Daten-Timestamp (z.B. …currentLocation.latitude.timestamp)
        const inner = latObj?.timestamp || lonObj?.timestamp;
        const keyStr = inner || msgTs || new Date().toISOString();
        // realTs = ms (für addTrackPoint)
        const realTs = Date.parse(inner || msgTs) || Date.now();
        return { keyStr, realTs };
    }

    function commitGroupIfReady(vin, keyStr) {
        const s = state[vin];
        const g = s.groups.get(keyStr);
        if (!g) return;

        if (typeof g.lat === "number" && typeof g.lon === "number") {
            // beide da → echten Punkt schreiben
            addTrackPoint(vin, g.lat, g.lon, g.realTs);
            s.lat = g.lat; s.lon = g.lon;
            maybeUpdateMarker(vin);
            if (g.timer) clearTimeout(g.timer);
            s.groups.delete(keyStr);
        }
    }

    function enqueueCoord(vin, keyStr, realTs, kind, value) {
        const s = state[vin];
        let g = s.groups.get(keyStr);
        if (!g) {
            g = { realTs };
            s.groups.set(keyStr, g);
            // Fallback: falls das Gegenstück nicht kommt, nach 1000ms trotzdem committen
            g.timer = setTimeout(() => {
                // Wenn nur eine Seite vorhanden ist, nehmen wir die jeweils letzte bekannte Gegenkoordinate,
                // damit der Marker/Linie nicht „einfriert“ – aber ohne Treppchen (weil pro ts nur ein Commit).
                if (typeof g.lat !== "number") g.lat = s.lat;
                if (typeof g.lon !== "number") g.lon = s.lon;
                commitGroupIfReady(vin, keyStr); // commit mit evtl. alten Gegenwerten
                s.groups.delete(keyStr);
            }, 1000);
        }
        g.realTs = realTs;        // falls später reinkommende Seite den genaueren ts hat
        g[kind] = value;          // kind = "lat" oder "lon"
        commitGroupIfReady(vin, keyStr);
    }

    function updateInfo(vin) {
        const s = state[vin];
        const count = s.track.length;
        const lastTime = count ? new Date(s.track[count-1].t).toLocaleString() : "–";
        info.textContent = `VIN: ${vin} • Punkte: ${count} • Letztes Update: ${lastTime}`;
        extraMeta.textContent = info.textContent;
    }

    function saveTrail(vin) {
        const s = state[vin];
        if (s.track.length > MAX_POINTS) s.track.splice(0, s.track.length - MAX_POINTS);
        const compact = s.track.map(p => ({ lat:+p.lat.toFixed(6), lon:+p.lon.toFixed(6), t:p.t }));
        localStorage.setItem(keyForVin(vin), JSON.stringify(compact));
    }

    function loadTrail(vin) {
        try {
        const raw = localStorage.getItem(keyForVin(vin));
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) state[vin].track = arr.filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon));
        } catch {}
    }

    function saveExtras(vin) {
        const s = state[vin];
        localStorage.setItem(keyForExtra(vin), JSON.stringify(s.extras || {}));
    }

    function loadExtras(vin) {
        try {
        const raw = localStorage.getItem(keyForExtra(vin));
        if (!raw) return;
        const obj = JSON.parse(raw);
        if (obj && typeof obj === "object") state[vin].extras = obj;
        } catch {}
    }

    function clearTrail(vin) {
        const s = state[vin];
        s.track = [];
        saveTrail(vin);
        if (s.polyline) s.polyline.setLatLngs([]);
        updateInfo(vin);
    }

    function clearAllTrails() {
        Object.keys(state).forEach(vin => {
        localStorage.removeItem(keyForVin(vin));
        localStorage.removeItem(keyForExtra(vin));
        if (state[vin].polyline) state[vin].polyline.setLatLngs([]);
        state[vin].track = [];
        state[vin].extras = {};
        updateInfo(vin);
        renderExtras(vin);
        });
    }

    function addTrackPoint(vin, lat, lon, ts = Date.now()) {
        const s = state[vin];
        const track = s.track;
        const last = track.length ? track[track.length - 1] : null;
        if (last) {
        const d = haversine(last.lat, last.lon, lat, lon);
        if (d < MIN_DIST_METERS) return;
        }
        const point = { lat, lon, t: typeof ts === "string" ? ts : new Date(ts).toISOString() };
        track.push(point);
        s.polyline.addLatLng([lat, lon]);
        saveTrail(vin);
        updateInfo(vin);
    }

    function maybeUpdateMarker(vin) {
        const s = state[vin];
        if (typeof s.lat === "number" && typeof s.lon === "number") {
        const pos = [s.lat, s.lon];
        if (!s.marker) s.marker = L.marker(pos).addTo(map);
        else s.marker.setLatLng(pos);
        s.marker.bindPopup(
            `<b>${vin}</b><br>Lat: ${s.lat.toFixed(6)}<br>Lon: ${s.lon.toFixed(6)}<br>${new Date().toLocaleTimeString()}`
        );
        map.setView(pos, Math.max(map.getZoom(), 13));
        }
    }

    function extractCoords(dataObj) {
        let lat = null, lon = null;
        const latObj = dataObj?.["vehicle.cabin.infotainment.navigation.currentLocation.latitude"];
        const lonObj = dataObj?.["vehicle.cabin.infotainment.navigation.currentLocation.longitude"];
        if (typeof latObj?.value === "number") lat = latObj.value;
        if (typeof lonObj?.value === "number") lon = lonObj.value;
        if (lat === null || lon === null) {
        for (const [k, v] of Object.entries(dataObj || {})) {
            const val = (v && typeof v === "object") ? v.value : undefined;
            if (typeof val === "number") {
            if (lat === null && k.endsWith(".latitude")) lat = val;
            if (lon === null && k.endsWith(".longitude")) lon = val;
            }
        }
        }
        return { lat, lon };
    }

    function collectExtras(dataObj) {
        const out = {};
        const isCoordKey = (k) => k.endsWith(".latitude") || k.endsWith(".longitude") ||
        k.includes(".currentLocation.latitude") || k.includes(".currentLocation.longitude");
        for (const [k, v] of Object.entries(dataObj || {})) {
        if (isCoordKey(k)) continue;
        if (v !== null && typeof v === "object" && ("value" in v)) {
            const unit = v.unit || v.units || "";
            const val = v.value;
            out[k] = (unit && (typeof val === "number" || typeof val === "string")) ? `${val} ${unit}` : val;
        } else if (["string","number","boolean"].includes(typeof v)) {
            out[k] = v;
        }
        }
        return out;
    }

    function renderExtras(vin) {
        const s = state[vin];
        const entries = Object.entries(s.extras || {});
console.log("🧱 renderExtras", { vin, count: entries.length });        
        if (!entries.length) {
        extraList.innerHTML = `<li><span class="k">–</span><span class="v">Noch nichts empfangen</span></li>`;
        return;
        }
        entries.sort((a,b)=> a[0].localeCompare(b[0]));
        const html = entries.map(([k,v]) => {
        const keyShort = k.split('.').slice(-2).join('.') || k;
        const val = (v === null || v === undefined) ? "—" : (typeof v === "object" ? JSON.stringify(v) : String(v));
        return `<li title="${k}"><span class="k">${keyShort}</span><span class="v">${val}</span></li>`;
        }).join("");
        extraList.innerHTML = html;
    }

    const client = mqtt.connect(brokerUrl, { reconnectPeriod:3000, connectTimeout:5000 });
    client.on('connect', () => { connDot.classList.remove('err'); connDot.classList.add('ok'); client.subscribe(subscribeTopic); });
    client.on('error', () => { connDot.classList.remove('ok'); connDot.classList.add('err'); });

    // ─────────────────────────────────────────────────────────────
// 1) State um Gruppierung nach Timestamp erweitern
// pro VIN: Map tsKey -> { lat?:number, lon?:number, realTs:number, timer?:number }
function ensureVin(vin) {
  if (!state[vin]) {
    state[vin] = { lat:null, lon:null, marker:null, polyline:null, track:[], extras:{},
                   groups: new Map() };
    loadTrail(vin);
    loadExtras(vin);
    state[vin].polyline = L.polyline(state[vin].track.map(p => [p.lat, p.lon]), { weight:4 }).addTo(map);
    updateInfo(vin);
    renderExtras(vin);
  }
  return state[vin];
}

// ─────────────────────────────────────────────────────────────
// 2) Hilfen: Timestamp bestimmen & Gruppe committen
function pickTsKeyAndMillis(msgTs, latObj, lonObj) {
  // bevorzugt den "inneren" Daten-Timestamp (z.B. …currentLocation.latitude.timestamp)
  const inner = latObj?.timestamp || lonObj?.timestamp;
  const keyStr = inner || msgTs || new Date().toISOString();
  // realTs = ms (für addTrackPoint)
  const realTs = Date.parse(inner || msgTs) || Date.now();
  return { keyStr, realTs };
}

function commitGroupIfReady(vin, keyStr) {
  const s = state[vin];
  const g = s.groups.get(keyStr);
  if (!g) return;

  if (typeof g.lat === "number" && typeof g.lon === "number") {
    // beide da → echten Punkt schreiben
    addTrackPoint(vin, g.lat, g.lon, g.realTs);
    s.lat = g.lat; s.lon = g.lon;
    maybeUpdateMarker(vin);
    if (g.timer) clearTimeout(g.timer);
    s.groups.delete(keyStr);
  }
}

function enqueueCoord(vin, keyStr, realTs, kind, value) {
  const s = state[vin];
  let g = s.groups.get(keyStr);
  if (!g) {
    g = { realTs };
    s.groups.set(keyStr, g);
    // Fallback: falls das Gegenstück nicht kommt, nach 400ms trotzdem committen
    g.timer = setTimeout(() => {
      // Wenn nur eine Seite vorhanden ist, nehmen wir die jeweils letzte bekannte Gegenkoordinate,
      // damit der Marker/Linie nicht „einfriert“ – aber ohne Treppchen (weil pro ts nur ein Commit).
      if (typeof g.lat !== "number") g.lat = s.lat;
      if (typeof g.lon !== "number") g.lon = s.lon;
      commitGroupIfReady(vin, keyStr); // commit mit evtl. alten Gegenwerten
      s.groups.delete(keyStr);
    }, 400);
  }
  g.realTs = realTs;        // falls später reinkommende Seite den genaueren ts hat
  g[kind] = value;          // kind = "lat" oder "lon"
  commitGroupIfReady(vin, keyStr);
}

    // Neuer MQTT-Handler: gruppiert Lat/Lon per Timestamp
    client.on('message', (topic, payload, packet) => {
        const raw = payload?.toString?.() ?? "";

        //console.log(topic, raw );
        // optionaler Debug-Filter:
        /*if (raw.includes("latitude") || raw.includes("longitude")) {
            console.log("📡 RX Koordinaten:", { topic, retained: packet?.retain, payload: raw });
        }*/

        let msg;
        try { msg = JSON.parse(raw); } catch { return; }

        const vin = msg.vin || msg.topic || "unknown";
        const data = msg.data || {};
        const s = ensureVin(vin);

        // Koordinaten & ihre "inneren" Objekte holen
        const latObj = data?.["vehicle.cabin.infotainment.navigation.currentLocation.latitude"];
        const lonObj = data?.["vehicle.cabin.infotainment.navigation.currentLocation.longitude"];

        // Zahlenwerte extrahieren (deine extractCoords kann bleiben, hier lesen wir zusätzlich die Objekte)
        const { lat, lon } = extractCoords(data);

        // key & ts bestimmen
        const { keyStr, realTs } = pickTsKeyAndMillis(msg.timestamp, latObj, lonObj);

        // jeweils vorhandene Seite in die passende Gruppe legen
        if (typeof lat === "number") enqueueCoord(vin, keyStr, realTs, "lat", lat);
        if (typeof lon === "number") enqueueCoord(vin, keyStr, realTs, "lon", lon);

        // Extras wie gehabt
        const extras = collectExtras(data);
        if (Object.keys(extras).length) {
            Object.assign(s.extras, extras);
            saveExtras(vin);
            renderExtras(vin);
        }
    });


    clearTrailBtn.addEventListener('click', () => {
        if (!confirm(`Trail für ${vin} löschen?`)) return;
        clearTrail(vin);
    });

    clearAllBtn.addEventListener('click', () => {
        if (!confirm("Alle Trails und Daten löschen?")) return;
        clearAllTrails();
    });

    (function restoreExistingTrails() {
        for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith(STORAGE_PREFIX)) {
            const vin = k.slice(STORAGE_PREFIX.length);
            ensureVin(vin);
            const s = state[vin];
            if (s.track.length) {
            const last = s.track[s.track.length - 1];
            s.lat = last.lat; s.lon = last.lon;
            maybeUpdateMarker(vin);
            }
        }
        }
        if (Object.keys(state).length === 0) {
        extraMeta.textContent = "Warte auf MQTT-Daten…";
        info.textContent = "Warte auf MQTT-Daten…";
        }
    })();
</script>
</body>
</html>
